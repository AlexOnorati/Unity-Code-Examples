//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34014
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
namespace TOP
{
	// Creates random maps based on 1's and 0's.
	public class Generate
	{
		public static readonly int[] mapX = {-1,1,0,0,0,0};
		public static readonly int[] mapZ = {0,0,-1,1,0,0};
		public static readonly int[] mapY = {0,0,0,0,-1,1};
		public static readonly int[] blockRef = {2,3,5,0,1,5};
		private static int[,,] map;
		private static Random randomValue;
		private static double ratio;
        private static string seedForMap;

		static public int[,,]Maze(int width, int length, int height, int seed, double givenRatio, int variance = 0){
			map = new int[width + 2, length + 2, height + 2];
            seed = seed + width + length + height + (int)(ratio * 100.0);

            randomValue = new Random (seed);
			ratio = givenRatio;
			ExtendMazeQuickFix  ();
			if (variance > 0) {
				AddVariance(variance);
			}
			return map;
		}

		static public void AddVariance(int range){
            if (range == 1) {
                range = 3;
            }
			for (int x = 0; x < map.GetLength(0); x++) { 
				for (int z = 0; z < map.GetLength(1); z++) { 
					for (int y = 0; y < map.GetLength(2); y++) {
						if(map[x,z,y] == 1)
							map[x,z,y] = randomValue.NextDouble() < ratio / 2.0 ? randomValue.Next(2, range) : 1;
					}
				}
			}
		}

		static private void ExtendMaze(int x, int z, int y, Random randomValue, double ratio){
			map [x, z, y] = 1;
			if (map [x - 1, z, y] == 0 && x - 1 != 0 && isAvailable(x - 1, z, y) && randomValue.NextDouble() < ratio) {
				ExtendMaze(x - 1, z, y, randomValue, ratio);
			}
			if (map [x + 1, z, y] == 0 && x + 1 != map.GetLength(0) - 1 && isAvailable(x + 1, z, y) && randomValue.NextDouble() < ratio) {
				ExtendMaze(x + 1, z, y, randomValue, ratio);
			}
			if (map [x, z - 1, y] == 0 && z - 1 != 0 && isAvailable(x, z - 1, y) && randomValue.NextDouble() < ratio) {
				ExtendMaze(x, z - 1, y, randomValue, ratio);
			}
			if (map [x, z + 1, y] == 0 && z + 1 != map.GetLength(1) - 1 && isAvailable(x, z + 1, y) && randomValue.NextDouble() < ratio) {
				ExtendMaze(x, z + 1,y, randomValue, ratio);
			}
			if (map [x, z, y - 1] == 0 && y - 1 != 0 && isAvailable(x, z, y - 1) && randomValue.NextDouble() < ratio) {
				ExtendMaze(x, z, y - 1, randomValue, ratio);
			}
			if (map [x, z, y + 1] == 0 && y + 1 != map.GetLength(2) - 1 && isAvailable(x, z, y + 1) && randomValue.NextDouble() < ratio) {
				ExtendMaze(x, z, y + 1, randomValue, ratio);
			}
		}

		static private void ExtendMazeQuick(){

			for (int x = 1; x < map.GetLength(0)-1; x++) { 
				for (int z = 1; z < map.GetLength(1)-1; z++) { 
					for (int y = 1; y < map.GetLength(2)-1; y++) {
						for(int v = 0; v < 6; v++){
							int newX = x + mapX[v];
							int newZ = z + mapZ[v];
							int newY = y + mapY[v];
							if(map[newX, newZ, newY] == 0 && IsNotAnEnd(map, newX, newZ, newY) && isAvailable(newX, newZ, newY) && randomValue.NextDouble() < ratio){
								map[newX, newZ, newY] = 1;
							}
						}
					}
				}
			}
		}

        private struct CordnatePathway{
            public int x;
            public int y;
            public int z;
        };

        static private CordnatePathway GenerateRandomPosition() {
            CordnatePathway randomCordnate = new CordnatePathway();
            randomCordnate.x = randomValue.Next(1, map.GetLength(0) - 1);
            randomCordnate.z = randomValue.Next(1, map.GetLength(1) - 1);
            randomCordnate.y = randomValue.Next(1, map.GetLength(2) - 1);
            return randomCordnate;
        }

        static private void ExtendMazeQuickFix()
        {

            List<CordnatePathway> cordnatePathways = new List<CordnatePathway>();
            CordnatePathway startingCordnate = GenerateRandomPosition();
            cordnatePathways.Add(startingCordnate);
            map[startingCordnate.x, startingCordnate.z, startingCordnate.y] = 1;

            int max = map.Length;
            int currentElementsChecked = 0;
            

           
                while (currentElementsChecked < max)
                {
                
                List<CordnatePathway> newPathways = new List<CordnatePathway>();
                if (cordnatePathways.Count > 0)
                {
                    foreach (CordnatePathway cordnate in cordnatePathways)
                    {
                        for (int directionIndex = 0; directionIndex < 6; directionIndex++)
                        {
                            int newX = cordnate.x + mapX[directionIndex];
                            int newZ = cordnate.z + mapZ[directionIndex];
                            int newY = cordnate.y + mapY[directionIndex];

                            if (IsNotAnEnd(map, newX, newZ, newY) && isAvailable(newX, newZ, newY))
                            {
                                if (map[newX, newZ, newY] == 0 && randomValue.NextDouble() < ratio)
                                {
                                    map[newX, newZ, newY] = 1;
                                    CordnatePathway newCordnate = new CordnatePathway();
                                    newCordnate.x = newX;
                                    newCordnate.y = newY;
                                    newCordnate.z = newZ;
                                    newPathways.Add(newCordnate);
                                    currentElementsChecked++;
                                }
                            }
                            else
                            {
                                currentElementsChecked++;
                            }
                        }
                    }
                }
                else {
                    currentElementsChecked = max;
                }
                cordnatePathways = newPathways;
            }

            map[startingCordnate.x, startingCordnate.z, startingCordnate.y] = -1;
              
           
        }

        static public bool IsNotAnEnd(int[,,] baseMap, int x, int z, int y){
			bool isXAnEnd = x > 0 && x < baseMap.GetLength (0) - 1;
			bool isZAnEnd = z > 0 && z < baseMap.GetLength (1) - 1;
			bool isYAnEnd = y > 0 && y < baseMap.GetLength (2) - 1;
			return isXAnEnd && isZAnEnd && isYAnEnd;
		}

		static private bool isAvailable(int x, int z, int y){
			int[] sideArea = new int[18];
			sideArea [0] = map [x + 1, z, y];
			sideArea [1] = map [x - 1, z, y];
			sideArea [2] = map [x, z + 1, y];
			sideArea [3] = map [x, z - 1, y];
			sideArea [4] = map [x, z, y + 1];
			sideArea [5] = map [x, z, y - 1];
			sideArea [6] = map [x + 1, z, y + 1];
			sideArea [7] = map [x + 1, z, y - 1];
			sideArea [8] = map [x - 1, z, y + 1];
			sideArea [9] = map [x - 1, z, y - 1];
			sideArea [10] = map [x, z + 1, y + 1];
			sideArea [11] = map [x, z - 1, y + 1];
			sideArea [12] = map [x, z + 1, y - 1];
			sideArea [13] = map [x, z - 1, y - 1];
			sideArea [14] = map [x + 1, z + 1, y ];
			sideArea [15] = map [x - 1, z + 1, y];
			sideArea [16] = map [x + 1, z - 1, y];
			sideArea [17] = map [x - 1, z - 1, y];
			bool yPlain = sideArea [0] + sideArea [14] + sideArea [2] != 3 && sideArea [2] + sideArea [15] + sideArea [1] != 3 && sideArea [1] + sideArea [17] + sideArea [3] != 3 && sideArea [3] + sideArea [16] + sideArea [0] != 3;

			bool xPlain = sideArea [1] + sideArea [8] + sideArea [4] != 3 && sideArea [4] + sideArea [6] + sideArea [0] != 3 && sideArea [0] + sideArea [7] + sideArea [5] != 3 && sideArea [5] + sideArea [9] + sideArea [1] != 3;

			bool zPlain = sideArea [2] + sideArea [10] + sideArea [4] != 3 && sideArea [4] + sideArea [11] + sideArea [3] != 3 && sideArea [3] + sideArea [13] + sideArea [5] != 3 && sideArea [5] + sideArea [12] + sideArea [2] != 3;

			return yPlain && xPlain && zPlain;
		}

		// Creates a randon 3D format maze.
		static public void DisconectedMaze(int width, int length, int height, int seed, double ratio){
			map = new int[width + 2, length + 2, height + 2];
			Random randomWithSeed = new Random (seed);
			for(int x = 0; x < map.GetLength(0); x++){
				for(int z = 0; z < map.GetLength(1); z++ ){
					for(int y = 0; y < map.GetLength(2); y++){
						map[x,z,y] = randomWithSeed.NextDouble() < ratio ? 1 : 0;
					}
				}
			}
			SmoothOutMaze ();
		}


		// Smooths out the 3D maze so it is only lines.
		static private void SmoothOutMaze(){
			for (int x = 0; x < map.GetLength(0); x++) { 
				for (int z = 0; z < map.GetLength(1); z++) { 
					for (int y = 0; y < map.GetLength(2); y++) {
						if (x == 0 || x == map.GetLength (0) - 1 || z == 0 || z == map.GetLength (1) - 1 || y == 0 || y == map.GetLength (2) - 1) {
							map [x, z, y] = 0;
						} else if (map [x, z, y] == 1) {
							int count = 1 + map [x, z - 1, y] + map [x, z - 1, y - 1] + map [x, z, y - 1] + map [x - 1, z, y] + map [x - 1, z - 1, y] + map [x - 1, z, y - 1] + map [x - 1, z - 1, y - 1];
							if (count > 4) {
								map [x, z, y] = 0;
							} else if (count == 4) {
								int xAxis = 1 + map [x - 1, z, y] + map [x, z - 1, y] + map [x - 1, z - 1, y];
								int yAxis = 1 + map [x, z, y - 1] + map [x - 1, z, y] + map [x - 1, z, y - 1];
								int zAxis = 1 + map [x, z - 1, y] + map [x, z, y - 1] + map [x, z - 1, y - 1];
								if (xAxis / 4 + yAxis / 4 + zAxis / 4 >= 1) {
									map [x, z, y] = 0;
								}
							}
						}
					}
				}
			}
			for (int x = 1; x < map.GetLength(0)-1; x++) { 
				for (int z = 1; z < map.GetLength(1)-1; z++) { 
					for (int y = 1; y < map.GetLength(2)-1; y++) {
						if(map[x-1,z,y] + map[x+1,z,y] + map[x,z-1,y] + map[x,z+1,y] + map[x,z,y-1] + map[x,z,y+1] == 0){
							map[x,z,y] = 0;
						}
					}
				}
			}
			for (int x = 1; x < map.GetLength(0)-1; x++) { 
				for (int z = 1; z < map.GetLength(1)-1; z++) { 
					for (int y = 1; y < map.GetLength(2)-1; y++) {
						GetObjectCount (x, z, y, 2, false);
					}
				}
			}
		}

		static private void GetObjectCount(int x, int z, int y, int n, bool hasAnotherMember){
			if (map [x, z, y] == 1) {
				map [x, z, y] = n;
				int members = hasAnotherMember ? 1 : 0;
				if (map [x + 1, z, y] == 1) {
					GetObjectCount (x + 1, z, y, n, true);
					members++;
				}
				if (map [x, z + 1, y] == 1) {
					GetObjectCount (x, z + 1, y, n, true);
					members++;
				}
				if (map [x, z, y + 1] == 1) {
					GetObjectCount (x, z + 1, y + 1, n, true);
					members++;
				}
				if (map [x - 1, z, y] == 1) {
					GetObjectCount (x - 1, z, y, n, true);
					members++;
				}
				if (map [x, z - 1, y] == 1) {
					GetObjectCount (x, z - 1, y, n, true);
					members++;
				}
				if (map [x, z, y - 1] == 1) {
					GetObjectCount (x, z, y - 1, n, true);
					members++;
				}
				if (members == 1) {
					map [x, z, y] = -n;
				}
			} else if (map [x, z, y] != 0) {
				if((map[x + 1,z,y] != 0 ? 1 : 0 + map[x - 1,z,y] != 0 ?  1 : 0 + map[x,z + 1,y] != 0 ? 1 : 0 + map[x,z - 1,y] != 0 ? 1 : 0 + map[x,z,y + 1] != 0 ? 1 : 0 + map[x,z,y - 1] != 0 ? 1 : 0) != 1){
					map[x,z,y] = (int)Math.Abs( map[x,z,y]);
				}
			}
		}
	}
}